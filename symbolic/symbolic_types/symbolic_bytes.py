from . symbolic_type import SymbolicObject
from symbolic.symbolic_types.symbolic_int import SymbolicInteger
#import SymbolicStr
from string import whitespace

# To handle the BOM problem of utf-8 encoding 
import codecs

# Refer to https://www.python.org/dev/peps/pep-0358/, and know what methods are supported
class SymbolicBytes(SymbolicObject, bytes):

    def __new__(cls, name, v, expr=None):
        '''
        # v can be either from the theorem prover or the initial value. 
        Regardless, v may be a str type. 
        This can happen especially when v is generated by the theorem prover, since we use str to solve the constraints in the prover.
        It will not generate bytes for you. You may need to cast it to bytes type.
        '''
        if not isinstance(v, bytes):
            # Usually, it should be str if not bytes
            if isinstance(v, str):
                v = v.encode('utf-8')
                print(v)
                print(type(v))
            else:
                print("Do not know the type of v when generating a new SymbolicBytes Object;")
        return bytes.__new__(cls, v)

    def __init__(self, name, v, expr=None):
        SymbolicObject.__init__(self, name, expr)
        self.val = v

    def getConcrValue(self):
        return self.val

    def wrap(conc, sym):
        return SymbolicBytes("se", conc, sym)

    def __hash__(self):
        return hash(self.val)

    def __bool__(self):
        return SymbolicObject.__bool__(self.__len__() != 0)

    def __len__(self):
        return self._do_sexpr([self], lambda x: len(x),
                                "str.len", SymbolicInteger.wrap)
    def __ne__(self, other):
        return self._do_bin_op(other, lambda x, y: x != y, "!=", SymbolicInteger.wrap)
    def translate(self,table, delete= None):
        if delete == None:
            self.val = self.val.translate(table)
            return SymbolicBytes(self.name, self.val, self.expr)
        else:
            self.val = self.val.translate(table, delete)
            return self

    # decode bytes to string
    def decode(self, encoding="utf-8", errors="strict"):
        decoded_str = self.val.decode(encoding, errors)
        if decoded_str.startswith(codecs.BOM_UTF8.decode('utf-8')):
            pass
        
        if isinstance(decoded_str, str):
            from symbolic.symbolic_types.symbolic_str import SymbolicStr
            return SymbolicStr(self.name, decoded_str, self.expr)
